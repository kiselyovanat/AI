***тут все функции, которые уже переписаны для больших чисел

beginBig(L1,k/L2) *** k - число столбцов(=число строк в матрице после транспонирования)
k⇒Q2 OL2 Q1⇒m ↑(m>32)1 *begin(L1,m/L2) →5 ***m - число строк(=число столбцов в матрице после транспонирования)
§1 ⁻i  m/32⇒e m;32⇒b↪2 ∆e ***e - число строк, которое занимает число, b - номер столбца, где конец числа
§2 *transpositionBig(L1,k,e/L2) ⁻j
§3 ∆i ↑(i>e)4 j@>L2 →3
§4 *printbigmat(32,e,L2/)
§5 **

transpositionBig(L1,k,e/L2) ***e-число строк, которое занимает число, k-число столбцов
k*e-1⇒Q2
OL2 ⁻i
§1 ∆i ↑(i=Q1)3 L1i⇒m
§2 ↑X1mj j*e⇒j i:32+j⇒j Z⇒q L2j∨Iq⇒L2j →2  ***в Z - остаток от деления i 32
§3 **

printbigmat(m,e,L1/)
	Oi @+F2(32)
§1 ↑(i≥Q1)4 Oj
§2 ↑(j=e)3
				j+i⇒k
        *output2(L1k,m/F2) /F2>C
				OQ2
				∆j →2
§3 /'\n'>C i+e⇒i →1
§4 **

downxorbig(L2,i,j,m/L2)
i>5⇒q i&31⇒r Ir⇒x j⇒k*m+q⇒t *** q,r - "координаты" i-го столбца в "секции" (№ строки и № бита)
§1 ∆k t+m⇒t ↑(t≥Q2)2 L2t&x ↪1 *big_xor(L2,j,k,m/L2) →1
§2 **

big_xor(L1,j,k,m/L1) *** прибавить к k-й секции j-ю, m - размер секции
   j*m⇒j+m⇒e k*m⇒k
§1 L1j⊕L1k⇒L1k ∆k ∆j⊕e↦1
**

notnullcolBig(L2,k,e/i) ***k - номер строки, с которой начинаем поиск ненулевого столбца,
                        ***e - количество строк, которое занимает число
k⇒j Ox ⁻n               *** как отловить нулевую матрицу(кусок матрицы?)
§1 ↑(j≥Q2)4
§2 ↑(l=e)3
        j+l⇒r
        L2r∨x⇒x
        x↪2 x!+32*e⇒h ↑(h≥n)3 h⇒n            *** 0! = 31 & I31! = 31
§3 j+e⇒j →1
§4 **

notnullcol(L2,k/i)
k-1⇒j Ox 32⇒i
§1 ∆j ↑(j=Q2)2 L2j∨x⇒x →1
§2 x ↪3  x!⇒i
§3 **

upperone(L2,k,i/j)
Ii⇒x k-1⇒l
§1 ∆l ↑(l=Q2)3 L2l&x ↪1
§2 l⇒j
§3 **
