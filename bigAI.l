main(/)
   @+F1(100) /'Введите n: '>C /F1<C *s2n(F1,10/n) *** число строк
	/'Введите m: '>C OQ1 /F1<C *s2n(F1,10/m) *** число элементов комплекса на одну строку
/'Введите i: '>C OQ1 /F1<C *s2n(F1,10/i) *** номер "обнуляемого" столбца
/'Введите j: '>C OQ1 /F1<C *s2n(F1,10/j) *** номер ведущей строки
   m*n⇒k @+L2(k)
   /'Введите  имя файла: '>C OQ1 /F1<C *fopen(F1,0/z) ⁻s 32⇒Q1
§1 ∆s⊕k↪2 *freadf(z,F1,0,32/t)
*input2(F1/a) a@>L2
*freadf(z,F1,0,1/t) →1
§2 *printmat(32,L2/) /'\n'>C
   *downxor(L2,i,j,m/L2)
 *printmat(32,L2/)
   *fclose(z/)
**

setAI(L1,l,m/a) ***l - число строк, m - число столбоцов***
@+L2(1000)
§1 *begin(L1,m/L2) 1⇒i ***транспонирование матрицы и добавление строки, состоящей из 1, n - число строк в матрице ***
§2  ↑(Q2>l)5 *rank(L2/r) ***ранг матрицы***
§3  ↑(r<Q2)5 ∆i Ii-1⇒e m-i⇒k e<k⇒s ***е - последнее сочетание, s - начальное***
§4 *monom(s,L2/L2) ↑(s=e)2 *sochz(s/s) →4
§5 i⇒a  **

begin(L1,m/L2)
m⇒Q2 OL2 ⁻i
§1 ∆i ↑(i=Q1)3 L1i⇒x
§2 ↑X1xj L2j∨Ii⇒L2j →2
§3 Ii-1@>L2 **  ***максимальный вектор записываем в конец***

beginBig(L1,m/L2) *** m - число столбцов
m⇒Q2 OL2 ↑(m>32)1 ⁻i ⁻j *begin(L1,m/L2) → 5
§1 m/32⇒a m;32⇒b↪2 ∆a ***a - число строк, которое занимает число, b - номер столбца, где конец числа
§2 ∆i ↑(i=a)4
§3 ↑(j>32)2

§5 **

transponir(L1,k,e/L2) ***e-число строк, которое занимает число, k-число столбцов
k*e-1⇒Q2
OL2 ⁻i
§1 ∆i ↑(i=Q1)3 L1i⇒m
§2 ↑X1mj j*e⇒j i:32+j⇒j Z⇒q L2j∨Iq⇒L2j →2  ***в Z - остаток от деления i 32
§3 **


getvector(d,F1,b,l/v)
@+F2(100) @'\n'>F2 Op
§1 *freadf(d,F1,b,l/k) ↑(F1p=F2.0)2 ∆b ∆Q1⇒p →1
§2 *input2(F1/v) **



******************************************************
rank(L2/r)
Ok @+L3(32) OL3 L2⇒L3 Q2⇒Q3
§1 *notnullcol(L3,k/i) ↑(i=32)4  *upperone(L3,k,i/j) ↑(k=j)2 ⇔(L3jk)
§2 *downxor(L3,i,k/L3)
§3  ∆k ↑(k=Q3)4 →1
§4 k⇒r **

notnullcol(L2,k/i)
k-1⇒j Ox 32⇒i
§1 ∆j ↑(j=Q2)2 L2j∨x⇒x →1
§2 x ↪3  x!⇒i
§3 **

upperone(L2,k,i/j)
Ii⇒x k-1⇒l
§1 ∆l ↑(l=Q2)3 L2l&x ↪1
§2 l⇒j
§3 **

downxor(L2,i,j/L2)
j⇒k Ii⇒x
§1 ∆k ↑(k=Q2)2 L2k&x ↪1 L2j⊕L2k⇒L2k →1
§2 **

sochz(s/s)
***/'sochz '>C
§1 s+1&s⇒b-1⊕s%-2⇒c
   s+1⊕s<1+1<c⊕b⇒s
§2 **

monom(s,L2/L2)
s⇒k ⁻x
§1 ↑X2kj L2j&x⇒x →1  *** в j - номер младшей единицы ***
§2 x@>L2 **

downxorbig(L2,i,j,m/L2)
i>5⇒q i&31⇒r Ir⇒x j⇒k*m+q⇒t *** q,r - "координаты" i-го столбца в "секции" (№ строки и № бита)
§1 ∆k t+m⇒t ↑(t≥Q2)2 L2t&x ↪1 *big_xor(L2,j,k,m/L2) →1
§2 **

big_xor(L1,j,k,m/L1) *** прибавить к k-й секции j-ю, m - размер секции
   j*m⇒j+m⇒e k*m⇒k
§1 L1j⊕L1k⇒L1k ∆k ∆j⊕e↦1
**
